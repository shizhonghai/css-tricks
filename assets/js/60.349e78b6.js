(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{662:function(e,t,a){"use strict";a.r(t);var v=a(69),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[e._v("#")]),e._v(" React-Fiber")]),e._v(" "),a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" 背景")]),e._v(" "),a("p",[a("code",[e._v("React")]),e._v(" 在进行组件渲染时，从 "),a("code",[e._v("setState")]),e._v(" 开始，到渲染完成，整个过程是同步的。\n如果需要渲染的组件比较庞大， js 执行会占据主线程时间较长，会导致页面响应度变差，使得 "),a("code",[e._v("React")]),e._v(" 在动画、手势等应用中效果比较差。")]),e._v(" "),a("h2",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[e._v("#")]),e._v(" 实现原理")]),e._v(" "),a("ul",[a("li",[e._v("旧版 "),a("code",[e._v("React")]),e._v(" 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，它会一直执行到栈空为止。")]),e._v(" "),a("li",[e._v("而 "),a("code",[e._v("Fiber")]),e._v(" 实现了自己的组件调用栈，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务。\n实现方式是使用了浏览器的 "),a("code",[e._v("requestldleCallback")]),e._v(" 这一 API。")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Fiber 算法原理")]),e._v(" "),a("p",[e._v("加入 "),a("code",[e._v("fiber")]),e._v(" 的 "),a("code",[e._v("react")]),e._v(" 将组建更新分为两个时期：phase1 和 phase2 ，这两个时期以 "),a("code",[e._v("render")]),e._v(" 为分界，"),a("code",[e._v("render")]),e._v("前的生命周期为 phase1，"),a("code",[e._v("render")]),e._v(" 后的生命周期为 phase2")]),e._v(" "),a("ul",[a("li",[e._v("phase1 的生命周期是可以被打断的。每个一段时间它会跳出当前渲染进程，去确定是否有其它更重要的任务。")]),e._v(" "),a("li",[e._v("phase2 的生命周期是不可被打断的。")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);