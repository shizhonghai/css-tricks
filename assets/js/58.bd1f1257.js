(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{659:function(v,_,e){"use strict";e.r(_);var t=e(69),c=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue和react的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue和react的区别"}},[v._v("#")]),v._v(" Vue和React的区别")]),v._v(" "),e("h2",{attrs:{id:"监听数据变化的实现原理不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#监听数据变化的实现原理不同"}},[v._v("#")]),v._v(" 监听数据变化的实现原理不同")]),v._v(" "),e("ol",[e("li",[v._v("Vue 通过 "),e("code",[v._v("getter/setter")]),v._v(" 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。")]),v._v(" "),e("li",[v._v("React 默认是通过比较引用的方式进行的，如果不优化（"),e("code",[v._v("PureComponent/shouldComponentUpdate")]),v._v("）可能导致大量不必要的 "),e("code",[v._v("VDom")]),v._v(" 的重新渲染。")])]),v._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[v._v("为什么 `React` 不精确监听数据变化呢？")]),v._v(" "),e("p",[v._v("这是因为 "),e("code",[v._v("Vue")]),v._v(" 和 "),e("code",[v._v("React")]),v._v(" 设计理念上的区别， "),e("code",[v._v("Vue")]),v._v(" 使用的是可变数据，而 "),e("code",[v._v("React")]),v._v(" 更强调数据的不可变。所以应该说没有好坏之分，"),e("code",[v._v("Vue")]),v._v("\n更加简单，而 "),e("code",[v._v("React")]),v._v(" 构建大型应用的时候更棒。")])]),v._v(" "),e("h2",{attrs:{id:"vue-和-react-的主要区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-的主要区别"}},[v._v("#")]),v._v(" Vue 和 React 的主要区别")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("Vue")]),v._v(" 是响应式的数据双向绑定系统，而 "),e("code",[v._v("React")]),v._v(" 是单向数据流，没有双向绑定。")]),v._v(" "),e("li",[e("code",[v._v("Vue")]),v._v(" 的语法较为简单，适用于小型项目创建，而 "),e("code",[v._v("React")]),v._v(" 更适用于 Web 端和原生 App 的开发，侧重于大型应用。")]),v._v(" "),e("li",[v._v("模块渲染方式的不同："),e("code",[v._v("React")]),v._v(" 是通过 JSX 渲染模板。而 "),e("code",[v._v("Vue")]),v._v(" 是通过一种扩展的 "),e("code",[v._v("Html")]),v._v(" 语法进行渲染。")])]),v._v(" "),e("h2",{attrs:{id:"react-优点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react-优点和缺点"}},[v._v("#")]),v._v(" React 优点和缺点")]),v._v(" "),e("p",[v._v("优点：")]),v._v(" "),e("ul",[e("li",[v._v("丰富的"),e("code",[v._v("JavaScript")]),v._v("库：来自世界各地的贡献者正在努力添加更多功能")]),v._v(" "),e("li",[v._v("可扩展性：由于其灵活的结构和可扩展性，"),e("code",[v._v("React")]),v._v(" 已被证明对大型应用程序更好。")]),v._v(" "),e("li",[e("code",[v._v("React")]),v._v(" 速度很快：它并不直接对 "),e("code",[v._v("DOM")]),v._v(" 进行操作，引入了一个叫做虚拟"),e("code",[v._v("Dom")]),v._v("的概念，安插在 js 逻辑和实际的 "),e("code",[v._v("DOM")]),v._v(" 之间，性能好，最大限度减少 "),e("code",[v._v("DOM")]),v._v(" 交互。")]),v._v(" "),e("li",[v._v("跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API。")]),v._v(" "),e("li",[v._v("一切都是组件：代码更加模块化，重用代码更容易，可维护性高。")]),v._v(" "),e("li",[e("code",[v._v("React")]),v._v(" 提供 "),e("code",[v._v("React Native")]),v._v(" 平台，可通过相同的 "),e("code",[v._v("React")]),v._v(" 组件模型为 ios 和 Android 开发本机呈现的应用程序。")])]),v._v(" "),e("p",[v._v("举个例子，说明 "),e("code",[v._v("React")]),v._v(" 的好处："),e("code",[v._v("React")]),v._v("中 "),e("code",[v._v("render")]),v._v(" 函数时支持闭包特性的，所以我们 "),e("code",[v._v("import")]),v._v(" 的组件在 "),e("code",[v._v("render")]),v._v(" 中可以直接调用。但是在 "),e("code",[v._v("Vue")]),v._v(" 中，由于模板中\n使用的数据都必须挂在 "),e("code",[v._v("this")]),v._v(" 上进行一次中转，所以我们 "),e("code",[v._v("import")]),v._v(" 一个组件完成了之后，还需要在 "),e("code",[v._v("components")]),v._v(" 中再声明下。")]),v._v(" "),e("p",[v._v("缺点：")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("React")]),v._v(" 只是一个视图库，而不是一个完整的框架。")]),v._v(" "),e("li",[v._v("对于 "),e("code",[v._v("Web")]),v._v(" 开发者来说，学习成本较高。")]),v._v(" "),e("li",[v._v("代码复杂性随着内联模板和 "),e("code",[v._v("JSX")]),v._v(" 的增加而增加。")]),v._v(" "),e("li",[v._v("如果有太多的小组件可能增加项目的庞大和复杂。")])]),v._v(" "),e("h2",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),e("ul",[e("li",[v._v("性能高效")]),v._v(" "),e("li",[v._v("双向数据绑定")]),v._v(" "),e("li",[v._v("学习难度低，上手简单")])])])}),[],!1,null,null,null);_.default=c.exports}}]);