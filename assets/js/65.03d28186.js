(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{667:function(t,e,a){"use strict";a.r(e);var s=a(69),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook"}},[t._v("#")]),t._v(" React Hook")]),t._v(" "),a("h2",{attrs:{id:"什么是-react-hook"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-react-hook"}},[t._v("#")]),t._v(" 什么是 React Hook？")]),t._v(" "),a("p",[a("strong",[t._v("“Hook 是 React 16.8 的新增特性。它可以让你在不编写 "),a("code",[t._v("class")]),t._v(" 的情况下使用 "),a("code",[t._v("state")]),t._v(" 以及其它的 React 特性。”")])]),t._v(" "),a("p",[t._v("从官网的这句话中，我们可以明确的知道，"),a("code",[t._v("Hook")]),t._v(" 增加了函数式组件中 "),a("code",[t._v("state")]),t._v(" 的使用，在之前函数式组件是无法拥有自己的状态，只能通过 "),a("code",[t._v("props")]),t._v("\n以及 "),a("code",[t._v("context")]),t._v(" 来渲染自己的 "),a("code",[t._v("UI")]),t._v("，而在业务逻辑中，有些场景必须要使用到 "),a("code",[t._v("state")]),t._v("，那么我们就只能将函数式组件定义为 "),a("code",[t._v("class")]),t._v(" 组件。\n而现在通过 "),a("code",[t._v("Hook")]),t._v("，我们可以轻松的在函数式组件中维护我们的状态，不需要更改为 "),a("code",[t._v("class")]),t._v(" 组件。")]),t._v(" "),a("p",[t._v("React 16.8 加入 "),a("code",[t._v("Hooks")]),t._v("，让 React 函数式组件更加灵活")]),t._v(" "),a("p",[a("code",[t._v("Hooks")]),t._v(" 之前，React 存在很多问题：")]),t._v(" "),a("ol",[a("li",[t._v("在组件间复用状态逻辑很难")]),t._v(" "),a("li",[t._v("复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。")]),t._v(" "),a("li",[a("code",[t._v("class")]),t._v(" 组件的 "),a("code",[t._v("this")]),t._v(" 指向问题")]),t._v(" "),a("li",[t._v("难以记忆的生命周期")])]),t._v(" "),a("p",[a("code",[t._v("Hooks")]),t._v(" 很好的解决了上述问题，"),a("code",[t._v("Hooks")]),t._v(" 提供了很多方法。")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("useState")]),t._v(" 返回有状态值，以及更新这个状态值的函数。")]),t._v(" "),a("li",[a("code",[t._v("useEffect")]),t._v(" 接受包含命令式，可能有副作用代码的函数。")]),t._v(" "),a("li",[a("code",[t._v("useContext")]),t._v(" 接受上下文对象（从 "),a("code",[t._v("React.createContext")]),t._v(" 返回的值）并返回当前上下文值。")]),t._v(" "),a("li",[a("code",[t._v("useReducer")]),t._v(" "),a("code",[t._v("useState")]),t._v(" 的替代方案。")]),t._v(" "),a("li",[a("code",[t._v("useCallback")]),t._v(" 返回一个回忆的 "),a("code",[t._v("memoized")]),t._v(" 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性。")]),t._v(" "),a("li",[a("code",[t._v("useMemo")]),t._v(" 纯的一个记忆函数。")]),t._v(" "),a("li",[a("code",[t._v("useRef")]),t._v(" 返回一个可变的 "),a("code",[t._v("ref")]),t._v(" 对象，其 "),a("code",[t._v(".current")]),t._v(" 属性被初始化为传递的参数。")]),t._v(" "),a("li",[a("code",[t._v("useMutationEffict")]),t._v(" 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发。")]),t._v(" "),a("li",[a("code",[t._v("useLayoutEffict")]),t._v(" DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染。")])]),t._v(" "),a("h2",{attrs:{id:"react-hook-要解决什么问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook-要解决什么问题"}},[t._v("#")]),t._v(" React Hook 要解决什么问题")]),t._v(" "),a("p",[a("code",[t._v("React Hooks")]),t._v(" 要解决的问题是状态共享，这里的状态共享是指只共享状态逻辑复用，并不是指数据之间的共享。")]),t._v(" "),a("h2",{attrs:{id:"react-hook-实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook-实现原理"}},[t._v("#")]),t._v(" React Hook 实现原理")]),t._v(" "),a("p",[t._v("Hooks 的基本类型：")]),t._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("type Hooks "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    memoizedState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("             "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向当前渲染节点 Fiber")]),t._v("\n    baseState"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("                 "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化 initialState，已经每次 dispatch 之后 newState")]),t._v("\n    baseUpdate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Update"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前需要更新的 Update，每次更新完之后，会赋值上一个 update，方便 react 在渲染错误的边缘，数据回溯")]),t._v("\n    queue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateQueue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// UpdateQueue 通过")]),t._v("\n    next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Hook "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("              "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// link 到下一个 hooks，通过 next 串联每一个 hooks")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\ntype Effect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    tag"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" HookEffectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("             "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// effectTag 标记当前 hook 作用在 life-cycles 的哪一个阶段")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" mixed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 初始化 callback")]),t._v("\n    destroy"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" mixed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 卸载 callback")]),t._v("\n    deps"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Array"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("mixed"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    next"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Effect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])]),a("p",[t._v("React Hooks 全局维护了一个 "),a("code",[t._v("workInProgressHook")]),t._v(" 变量，每一次调取 Hooks API 都会首先调取 "),a("code",[t._v("createWorkInProgressHook")]),t._v(" 函数。")]),t._v(" "),a("p",[t._v("当我们了解 React Hooks 的简单原理，得到 Hooks 的串联不是一个数组，但是是一个链式的数据结构，从根节点 "),a("code",[t._v("workInProgressHook")]),t._v(" 向下通过\n"),a("code",[t._v("next")]),t._v(" 进行串联。这也就是为什么 Hooks 不能嵌套使用，不能再条件判断中使用，不能再循环中使用。否则会破坏链式结构。")]),t._v(" "),a("h2",{attrs:{id:"生命周期的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期的区别"}},[t._v("#")]),t._v(" 生命周期的区别")]),t._v(" "),a("p",[t._v("函数组件的本质是函数，没有 "),a("code",[t._v("State")]),t._v(" 的概念的，因此不存在生命周期一说，仅仅是一个 "),a("code",[t._v("render")]),t._v(" 函数而已。")]),t._v(" "),a("p",[t._v("但是引入 Hooks 之后就变得不同了，它能让组件在不使用 "),a("code",[t._v("class")]),t._v(" 的情况下拥有 "),a("code",[t._v("state")]),t._v("，所以就有了生命周期的概念，所谓的生命周期其实就是\n"),a("code",[t._v("useState")]),t._v("、"),a("code",[t._v("useEffect")]),t._v(" 和 "),a("code",[t._v("useLayoutEffect")]),t._v("。")]),t._v(" "),a("p",[t._v("即：Hooks 组件（使用了 Hooks 的函数组件）有生命周期，而函数组件（未使用 Hooks 的函数组件）是没有生命周期的。")]),t._v(" "),a("p",[t._v("下面，是具体的 class 和 Hooks 的生命周期对应关系：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("class 组件")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("Hooks 组件")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("constructor")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("useState")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("getDerivedStateFromProps")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("useState 里面 update 函数")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("shouldComponentUpdate")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("useMemo")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("render")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("函数本身")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("componentDidMount")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("useEffect")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("componentDidUpdate")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("useEffect")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("componentWillUnmount")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("useEffect 里面返回的函数")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("componentDidCatch")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("无")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("getDerivedStateFromError")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("无")])])])])])}),[],!1,null,null,null);e.default=n.exports}}]);